

<!DOCTYPE html>
<html lang="en">
<head>
<title>Overriding the Insertion Operator for C++ Template Classes - Joe Yates' Blog</title>
<meta content="How to implement the << operator" name="description">
<meta content="width=device-width" name="viewport">
<link href="/sitemap.xml" rel="sitemap" title="Sitemap" type="application/xml">
<link href="/assets/app-cb475e5b8a234b2a45f4bc6cceeb180c.css" media="all" rel="stylesheet">
<script defer="true" src="/assets/application-04330b44b64bd6872cdc831811bd0720.js" type="text/javascript"></script>
</head>
<body class="font-sans text-xl bg-olive flex justify-center">
<div class="max-w-full min-h-screen md:w-[40rem] bg-light-olive py-4 px-10 flex flex-col">
<header>
<nav>
<ul class="flex list-none">
<li class="mr-8">
<a href="/">Home</a></li>
<li class="mr-8">
<a href="/posts/">Archives</a></li>
<li>
<a href="/categories/">Categories</a></li></ul></nav>
<div class="prose">
<h1>
Overriding the Insertion Operator for C++ Template Classes</h1></div></header>

<main class="max-w-full grow mx-1">

<section class="space-y-4 prose">
<div class="flex justify-end mb-4">
<div>2011/03/06</div>
</div>
<h2 class="text-lg">
How to implement the << operator
</h2>
<p>While working on my <a href="https://github.com/joeyates/cpp-active-record/" target="_blank">C++ ActiveRecord implementation</a>, I had a few problems implementing the insertion operator for the main ActiveRecord::Base class.</p><p>I wanted to dump an Active Record object to Standard Out:</p><pre title="language: cpp"><code class="language-cpp">Person person(123);
std::cout &lt;&lt; person &lt;&lt; endl;</code></pre><p>The class ActiveRecord::Base class is a template class, and the problem was how to correctly declare the operator.</p><p>At the time I was unable to find examples on the Internet, so I thought I'd provide my own.</p><h1>The Insertion Operator</h1><p>By "insertion operator" I mean</p><pre title="language: cpp"><code class="language-cpp">ostream & operator&lt;&lt;(ostream &out_stream, const C& c);</code></pre><p>This is a global function that can be called like this:</p><pre title="language: cpp"><code class="language-cpp">std::cout &lt;&lt; c;</code></pre><p>This operator allows you to output a string representation of your classes, which is very handy for debugging:</p><pre title="language: cpp"><code class="language-cpp">C c;
c.do_stuff();
std::cout &lt;&lt; c &lt;&lt; endl;</code></pre><h1>The Example</h1><h2>A Class</h2><p>Here's an example class which (rather reduntantly) wraps an STL std::list:</p><pre title="language: cpp"><code class="language-cpp">#include &lt;list>

using namespace std;

template &lt; class T >
class MyList {
 public:
  MyList() {};

  void add( T item ) {
    data_.push_back( item );
  }

  int length() const {
    return data_.size();
  }

 private:
  list&lt; T > data_;
};</code></pre><h2>Serialization</h2><p>While debugging and testing, it would be handy to be able to output a string representation of an instance of this class.</p><pre title="language: cpp"><code class="language-cpp">MyList&lt;int> ints;
ints.add(42);
ints.add(13);
std::cout &lt;&lt; ints &lt;&lt; endl;
Which should work like this:
$ ./my_list
2 items:
  42
  13</code></pre><h2>Implementation</h2><p>Here's an implementation that just outputs the number of items:</p><pre title="language: cpp"><code class="language-cpp">template&lt; class T >
ostream & operator&lt;&lt;( ostream &out_stream, const MyList&lt; T >& a_list ) {
  out_stream &lt;&lt; a_list.length() &lt;&lt; " items:" &lt;&lt; endl;
  return out_stream;
}</code></pre><p>Next, we want the operator to iterate over the <code>list<T></code> member and output its values.</p><p>The main sticking point for me here was the declaration of the iterator. The following is not sufficient:</p><pre title="language: cpp"><code class="language-cpp">...
for( list&lt;T>::const_iterator it = a_list.data_.begin(); it != a_list.data_.end(); ++it ) {
...</code></pre><p>and produces this error message (with gcc):</p><pre title="language: plaintext"><code class="language-plaintext">to_ostream.cpp: In function 'std::ostream& operator&lt;&lt;(std::ostream&, const MyList&lt;T>&)':
to_ostream.cpp:7: error: expected `;' before 'it'
to_ostream.cpp:7: error: 'it' was not declared in this scope</code></pre><p>What's missing is the <code>typename</code> keyword to tell the compiler that we're instantiating an iterator:</p><pre title="language: cpp"><code class="language-cpp">...
for(typename list&lt;T>::const_iterator it = a_list.data_.begin(); it != a_list.data_.end(); ++it) {
...</code></pre><p>Here's the final implementation:</p><pre title="language: cpp"><code class="language-cpp">template&lt; class T >
ostream & operator&lt;&lt;( ostream &out_stream, const MyList&lt; T >& a_list ) {
  out_stream &lt;&lt; a_list.length() &lt;&lt; " items:" &lt;&lt; endl;
  for( typename list&lt;T>::const_iterator it = a_list.data_.begin(); it != a_list.data_.end(); ++it ) {
    out_stream &lt;&lt; "\t" &lt;&lt; *it &lt;&lt; endl;
  }
  return out_stream;
}</code></pre><p>The function also has to access the private <code>data_</code> member, which entails declaring it as a <code>friend</code>:</p><pre title="language: cpp"><code class="language-cpp">template &lt; class T >
class MyList {
 template&lt; class T1 >
 friend ostream & operator&lt;&lt;( ostream &out_stream, const MyList&lt; T1 >& a_list );
 ...
};</code></pre><p>Here's the whole class with the operator:</p><pre title="language: cpp"><code class="language-cpp">#include &lt;iostream>
#include &lt;list>

using namespace std;

template &lt; class T >
class MyList {
 template&lt; class T1 >
 friend ostream & operator&lt;&lt;( ostream &out_stream, const MyList&lt; T1 >& a_list );
 public:
  void add( T item ) {
    data_.push_back( item );
  }
  
  int length() const {
    return data_.size();
  }
 private:
  list&lt; T > data_;
};

template&lt; class T >
ostream & operator&lt;&lt;( ostream &out_stream, const MyList&lt; T >& a_list ) {
  out_stream &lt;&lt; a_list.length() &lt;&lt; " items:" &lt;&lt; endl;
  for( typename list&lt;T>::const_iterator it = a_list.data_.begin(); it != a_list.data_.end(); ++it ) {
    out_stream &lt;&lt; "\t" &lt;&lt; *it &lt;&lt; endl;
  }
  return out_stream;
}</code></pre><p>And here's an example of it's use:</p><pre title="language: cpp"><code class="language-cpp">#include &lt;string>

int main( int argc, char **argv ) {
  MyList&lt; int > my_ints;
  my_ints.add( 1 );
  my_ints.add( 2 );

  cout &lt;&lt; "myints" &lt;&lt; endl;
  cout &lt;&lt; my_ints &lt;&lt; endl;

  MyList&lt; string > my_strings;
  my_strings.add( "hello" );
  my_strings.add( "world" );

  cout &lt;&lt; "mystrings" &lt;&lt; endl;
  cout &lt;&lt; my_strings &lt;&lt; endl;

  return 0;
}</code></pre><p>The output:</p><pre title="language: plaintext"><code class="language-plaintext">$ ./to_ostream 
myints
2 items:
        1
        2

mystrings
2 items:
        hello
        world</code></pre>
</section>
<ul class="paginate">
<li>

<a href="/posts/html-history-api/">← Newer</a></li>
<li>

<a href="/posts/hello-gosu/">Older →</a></li></ul>
</main>
<footer class="bottom-0 mt-6">
<hr class="mb-4">

<div class="flex flex-row justify-between text-sm">
<div>
<span>Made with</span>
<a href="https://github.com/joeyates/fermo">Fermo</a>
</div>
<p>&copy; Joe Yates 2011</p>
</div></footer>
</div></body></html>
